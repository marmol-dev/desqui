<html>
      <head></head>
      <body>
        <h1>The book</h1>
        <div id="content"><div id="PageTitle"><h1>Processes and Threads</h1></div><div id="PageContent">

<p>In concurrent programming, there are two basic units of execution: <i>processes</i> and <i>threads</i>. In the Java programming language, concurrent programming is mostly concerned with threads. However, processes are also important.</p>
<p>A computer system normally has many active processes and threads. This is true even in systems that only have a single execution core, and thus only have one thread actually executing at any given moment. Processing time for a single core is shared among processes and threads through an OS feature called time slicing.</p>
<p>It&apos;s becoming more and more common for computer systems to have multiple processors or processors with multiple execution cores. This greatly enhances a system&apos;s capacity for concurrent execution of processes and threads &#x2014; but concurrency is possible even on simple systems, without multiple processors or execution cores.</p>
<h2>Processes</h2>
<p>A process has a self-contained execution environment. A process generally has a complete, private set of basic run-time resources; in particular, each process has its own memory space.</p>
<p>Processes are often seen as synonymous with programs or applications. However, what the user sees as a single application may in fact be a set of cooperating processes. To facilitate communication between processes, most operating systems support <i>Inter Process Communication</i> (IPC) resources, such as pipes and sockets. IPC is used not just for communication between processes on the same system, but processes on different systems.</p>
<p>Most implementations of the Java virtual machine run as a single process. A Java application can create additional processes using a 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/lang/ProcessBuilder.html"><code>ProcessBuilder</code></a> object. Multiprocess applications are beyond the scope of this lesson.</p>
<h2>Threads</h2>
<p>Threads are sometimes called <i>lightweight processes</i>. Both processes and threads provide an execution environment, but creating a new thread requires fewer resources than creating a new process.</p>
<p>Threads exist within a process &#x2014; every process has at least one. Threads share the process&apos;s resources, including memory and open files. This makes for efficient, but potentially problematic, communication.</p>
<p>Multithreaded execution is an essential feature of the Java platform. Every application has at least one thread &#x2014; or several, if you count &quot;system&quot; threads that do things like memory management and signal handling. But from the application programmer&apos;s point of view, you start with just one thread, called the <i>main thread</i>. This thread has the ability to create additional threads, as we&apos;ll demonstrate in the next section.</p>

        </div><div id="PageTitle"><h1>Thread Objects</h1></div><div id="PageContent">

<p>Each thread is associated with an instance of the class 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html"><code>Thread</code></a>. There are two basic strategies for using <code>Thread</code> objects to create a concurrent application.</p>
<ul>
<li>To directly control thread creation and management, simply instantiate <code>Thread</code> each time the application needs to initiate an asynchronous task.</li>
<li>To abstract thread management from the rest of your application, pass the application&apos;s tasks to an <i>executor</i>.</li>
</ul>
<p>This section documents the use of <code>Thread</code> objects. Executors are discussed with other <a href="highlevel.html">high-level concurrency objects</a>.</p>

        </div><div id="PageTitle"><h1>Defining and Starting a Thread</h1></div><div id="PageContent">

<p>An application that creates an instance of <code>Thread</code> must provide the code that will run in that thread. There are two ways to do this:</p>
<ul>
<li><em>Provide a <code>Runnable</code> object.</em> The 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html"><code>Runnable</code></a> interface defines a single method, <code>run</code>, meant to contain the code executed in the thread. The <code>Runnable</code> object is passed to the <code>Thread</code> constructor, as in the 
<a class="SourceLink" target="_blank" href="examples/HelloRunnable.java" onclick="showCode(&apos;../../displayCode.html&apos;, &apos;examples/HelloRunnable.java&apos;); return false;"><code><code>HelloRunnable</code></code></a> example:
<div class="codeblock"><pre>

public class HelloRunnable implements Runnable {

    public void run() {
        System.out.println(&quot;Hello from a thread!&quot;);
    }

    public static void main(String args[]) {
        (new Thread(new HelloRunnable())).start();
    }

}
</pre></div>
</li>
<li><em>Subclass <code>Thread</code>.</em> The <code>Thread</code> class itself implements <code>Runnable</code>, though its <code>run</code> method does nothing. An application can subclass <code>Thread</code>, providing its own implementation of <code>run</code>, as in the 
<a class="SourceLink" target="_blank" href="examples/HelloThread.java" onclick="showCode(&apos;../../displayCode.html&apos;, &apos;examples/HelloThread.java&apos;); return false;"><code><code>HelloThread</code></code></a> example:
<div class="codeblock"><pre>

public class HelloThread extends Thread {

    public void run() {
        System.out.println(&quot;Hello from a thread!&quot;);
    }

    public static void main(String args[]) {
        (new HelloThread()).start();
    }

}
</pre></div>
</li>
</ul>
<p>Notice that both examples invoke <code>Thread.start</code> in order to start the new thread.</p>
<p>Which of these idioms should you use? The first idiom, which employs a <code>Runnable</code> object, is more general, because the <code>Runnable</code> object can subclass a class other than <code>Thread</code>. The second idiom is easier to use in simple applications, but is limited by the fact that your task class must be a descendant of <code>Thread</code>. This lesson focuses on the first approach, which separates the <code>Runnable</code> task from the <code>Thread</code> object that executes the task. Not only is this approach more flexible, but it is applicable to the high-level thread management APIs covered later.</p>
<p>The <code>Thread</code> class defines a number of methods useful for thread management. These include <code>static</code> methods, which provide information about, or affect the status of, the thread invoking the method. The other methods are invoked from other threads involved in managing the thread and <code>Thread</code> object. We&apos;ll examine some of these methods in the following sections.</p>


        </div><div id="PageTitle"><h1>Pausing Execution with Sleep</h1></div><div id="PageContent">

<p><code>Thread.sleep</code> causes the current thread to suspend execution for a specified period. This is an efficient means of making processor time available to the other threads of an application or other applications that might be running on a computer system. The <code>sleep</code> method can also be used for pacing, as shown in the example that follows, and waiting for another thread with duties that are understood to have time requirements, as with the <code>SimpleThreads</code> example in a later section.</p>
<p>Two overloaded versions of <code>sleep</code> are provided: one that specifies the sleep time to the millisecond and one that specifies the sleep time to the nanosecond. However, these sleep times are not guaranteed to be precise, because they are limited by the facilities provided by the underlying OS. Also, the sleep period can be terminated by interrupts, as we&apos;ll see in a later section. In any case, you cannot assume that invoking <code>sleep</code> will suspend the thread for precisely the time period specified.</p>
<p>The 
<a class="SourceLink" target="_blank" href="examples/SleepMessages.java" onclick="showCode(&apos;../../displayCode.html&apos;, &apos;examples/SleepMessages.java&apos;); return false;"><code><code>SleepMessages</code></code></a> example uses <code>sleep</code> to print messages at four-second intervals:</p>
<div class="codeblock"><pre>

public class SleepMessages {
    public static void main(String args[])
        throws InterruptedException {
        String importantInfo[] = {
            &quot;Mares eat oats&quot;,
            &quot;Does eat oats&quot;,
            &quot;Little lambs eat ivy&quot;,
            &quot;A kid will eat ivy too&quot;
        };

        for (int i = 0;
             i &lt; importantInfo.length;
             i++) {
            //Pause for 4 seconds
            Thread.sleep(4000);
            //Print a message
            System.out.println(importantInfo[i]);
        }
    }
}
</pre></div>
<p>Notice that <code>main</code> declares that it <code>throws InterruptedException</code>. This is an exception that <code>sleep</code> throws when another thread interrupts the current thread while <code>sleep</code> is active. Since this application has not defined another thread to cause the interrupt, it doesn&apos;t bother to catch <code>InterruptedException</code>.</p>


        </div><div id="PageTitle"><h1>Interrupts</h1></div><div id="PageContent">

<p>An <i>interrupt</i> is an indication to a thread that it should stop what it is doing and do something else. It&apos;s up to the programmer to decide exactly how a thread responds to an interrupt, but it is very common for the thread to terminate. This is the usage emphasized in this lesson.</p>
<p>A thread sends an interrupt by invoking 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#interrupt--"><code>interrupt</code></a> on the <code>Thread</code> object for the thread to be interrupted. For the interrupt mechanism to work correctly, the interrupted thread must support its own interruption.</p>
<h2>Supporting Interruption</h2>
<p>How does a thread support its own interruption? This depends on what it&apos;s currently doing. If the thread is frequently invoking methods that throw <code>InterruptedException</code>, it simply returns from the <code>run</code> method after it catches that exception. For example, suppose the central message loop in the <code>SleepMessages</code> example were in the <code>run</code> method of a thread&apos;s <code>Runnable</code> object. Then it might be modified as follows to support interrupts:</p>
<div class="codeblock"><pre>
for (int i = 0; i &lt; importantInfo.length; i++) {
    // Pause for 4 seconds
    try {
        Thread.sleep(4000);
    } catch (InterruptedException e) {
        // We&apos;ve been interrupted: no more messages.
        return;
    }
    // Print a message
    System.out.println(importantInfo[i]);
}
</pre></div>
<p>Many methods that throw <code>InterruptedException</code>, such as <code>sleep</code>, are designed to cancel their current operation and return immediately when an interrupt is received.</p>
<p>What if a thread goes a long time without invoking a method that throws <code>InterruptedException</code>? Then it must periodically invoke <code>Thread.interrupted</code>, which returns <code>true</code> if an interrupt has been received. For example:</p>
<div class="codeblock"><pre>
for (int i = 0; i &lt; inputs.length; i++) {
    heavyCrunch(inputs[i]);
    if (Thread.interrupted()) {
        // We&apos;ve been interrupted: no more crunching.
        return;
    }
}
</pre></div>
<p>In this simple example, the code simply tests for the interrupt and exits the thread if one has been received. In more complex applications, it might make more sense to throw an <code>InterruptedException</code>:</p>
<div class="codeblock"><pre>
if (Thread.interrupted()) {
    throw new InterruptedException();
}
</pre></div>
<p>This allows interrupt handling code to be centralized in a <code>catch</code> clause.</p>
<h2>The Interrupt Status Flag</h2>
<p>The interrupt mechanism is implemented using an internal flag known as the <i>interrupt status</i>. Invoking <code>Thread.interrupt</code> sets this flag. When a thread checks for an interrupt by invoking the static method <code>Thread.interrupted</code>, interrupt status is cleared. The non-static <code>isInterrupted</code> method, which is used by one thread to query the interrupt status of another, does not change the interrupt status flag.</p>
<p>By convention, any method that exits by throwing an <code>InterruptedException</code> clears interrupt status when it does so. However, it&apos;s always possible that interrupt status will immediately be set again, by another thread invoking <code>interrupt</code>.</p>

        </div><div id="PageTitle"><h1>Joins</h1></div><div id="PageContent">

<p>The <code>join</code> method allows one thread to wait for the completion of another. If <code>t</code> is a <code>Thread</code> object whose thread is currently executing,</p>
<div class="codeblock"><pre>
t.join();
</pre></div>
<p>causes the current thread to pause execution until <code>t</code>&apos;s thread terminates. Overloads of <code>join</code> allow the programmer to specify a waiting period. However, as with <code>sleep</code>, <code>join</code> is dependent on the OS for timing, so you should not assume that <code>join</code> will wait exactly as long as you specify.</p>
<p>Like <code>sleep</code>, <code>join</code> responds to an interrupt by exiting with an <code>InterruptedException</code>.</p>

        </div><div id="PageTitle"><h1>The SimpleThreads Example</h1></div><div id="PageContent">

<p>The following example brings together some of the concepts of this section. 
<a class="SourceLink" target="_blank" href="examples/SimpleThreads.java" onclick="showCode(&apos;../../displayCode.html&apos;, &apos;examples/SimpleThreads.java&apos;); return false;"><code>SimpleThreads</code></a> consists of two threads. The first is the main thread that every Java application has. The main thread creates a new thread from the <code>Runnable</code> object, <code>MessageLoop</code>, and waits for it to finish. If the <code>MessageLoop</code> thread takes too long to finish, the main thread interrupts it.</p>
<p>The <code>MessageLoop</code> thread prints out a series of messages. If interrupted before it has printed all its messages, the <code>MessageLoop</code> thread prints a message and exits.</p>
<div class="codeblock"><pre>

public class SimpleThreads {

    // Display a message, preceded by
    // the name of the current thread
    static void threadMessage(String message) {
        String threadName =
            Thread.currentThread().getName();
        System.out.format(&quot;%s: %s%n&quot;,
                          threadName,
                          message);
    }

    private static class MessageLoop
        implements Runnable {
        public void run() {
            String importantInfo[] = {
                &quot;Mares eat oats&quot;,
                &quot;Does eat oats&quot;,
                &quot;Little lambs eat ivy&quot;,
                &quot;A kid will eat ivy too&quot;
            };
            try {
                for (int i = 0;
                     i &lt; importantInfo.length;
                     i++) {
                    // Pause for 4 seconds
                    Thread.sleep(4000);
                    // Print a message
                    threadMessage(importantInfo[i]);
                }
            } catch (InterruptedException e) {
                threadMessage(&quot;I wasn&apos;t done!&quot;);
            }
        }
    }

    public static void main(String args[])
        throws InterruptedException {

        // Delay, in milliseconds before
        // we interrupt MessageLoop
        // thread (default one hour).
        long patience = 1000 * 60 * 60;

        // If command line argument
        // present, gives patience
        // in seconds.
        if (args.length &gt; 0) {
            try {
                patience = Long.parseLong(args[0]) * 1000;
            } catch (NumberFormatException e) {
                System.err.println(&quot;Argument must be an integer.&quot;);
                System.exit(1);
            }
        }

        threadMessage(&quot;Starting MessageLoop thread&quot;);
        long startTime = System.currentTimeMillis();
        Thread t = new Thread(new MessageLoop());
        t.start();

        threadMessage(&quot;Waiting for MessageLoop thread to finish&quot;);
        // loop until MessageLoop
        // thread exits
        while (t.isAlive()) {
            threadMessage(&quot;Still waiting...&quot;);
            // Wait maximum of 1 second
            // for MessageLoop thread
            // to finish.
            t.join(1000);
            if (((System.currentTimeMillis() - startTime) &gt; patience)
                  &amp;&amp; t.isAlive()) {
                threadMessage(&quot;Tired of waiting!&quot;);
                t.interrupt();
                // Shouldn&apos;t be long now
                // -- wait indefinitely
                t.join();
            }
        }
        threadMessage(&quot;Finally!&quot;);
    }
}
</pre></div>

        </div><div id="PageTitle"><h1>Synchronization</h1></div><div id="PageContent">

<p>Threads communicate primarily by sharing access to fields and the objects reference fields refer to. This form of communication is extremely efficient, but makes two kinds of errors possible: <i>thread interference</i> and <i>memory consistency errors</i>. The tool needed to prevent these errors is <i>synchronization</i>.</p>

<p>However, synchronization can introduce <a name="thread_contention"><em>thread contention</em></a>, which occurs when two or more threads try to access the same resource simultaneously <em>and</em> cause the Java runtime to execute one or more threads more slowly, or even suspend their execution.
<a class="TutorialLink" target="_top" href="../../essential/concurrency/starvelive.html">Starvation and livelock</a> are forms of thread contention. See the section
<a class="TutorialLink" target="_top" href="../../essential/concurrency/liveness.html">Liveness</a> for more information.</p>
 
<p>This section covers the following topics:</p>

<ul>
<li><a href="interfere.html">Thread Interference</a> describes how errors are introduced when multiple threads access shared data.</li>
<li><a href="memconsist.html">Memory Consistency Errors</a> describes errors that result from inconsistent views of shared memory.</li>
<li><a href="syncmeth.html">Synchronized Methods</a> describes a simple idiom that can effectively prevent thread interference and memory consistency errors.</li>
<li><a href="locksync.html">Implicit Locks and Synchronization</a> describes a more general synchronization idiom, and describes how synchronization is based on implicit locks.</li>
<li><a href="atomic.html">Atomic Access</a> talks about the general idea of operations that can&apos;t be interfered with by other threads.</li>
</ul>


        </div><div id="PageTitle"><h1>Thread Interference</h1></div><div id="PageContent">

<p>Consider a simple class called 
<a class="SourceLink" target="_blank" href="examples/Counter.java" onclick="showCode(&apos;../../displayCode.html&apos;, &apos;examples/Counter.java&apos;); return false;"><code><code>Counter</code></code></a></p>
<div class="codeblock"><pre>

class Counter {
    private int c = 0;

    public void increment() {
        c++;
    }

    public void decrement() {
        c--;
    }

    public int value() {
        return c;
    }

}
</pre></div>
<p><code>Counter</code> is designed so that each invocation of <code>increment</code> will add 1 to <code>c</code>, and each invocation of <code>decrement</code> will subtract 1 from <code>c</code>. However, if a <code>Counter</code> object is referenced from multiple threads, interference between threads may prevent this from happening as expected.</p>
<p>Interference happens when two operations, running in different threads, but acting on the same data, <i>interleave</i>. This means that the two operations consist of multiple steps, and the sequences of steps overlap.</p>
<p>It might not seem possible for operations on instances of <code>Counter</code> to interleave, since both operations on <code>c</code> are single, simple statements. However, even simple statements can translate to multiple steps by the virtual machine. We won&apos;t examine the specific steps the virtual machine takes &#x2014; it is enough to know that the single expression <code>c++</code> can be decomposed into three steps:</p>
<ol>
<li>Retrieve the current value of <code>c</code>.</li>
<li>Increment the retrieved value by 1.</li>
<li>Store the incremented value back in <code>c</code>.</li>
</ol>
<p>The expression <code>c--</code> can be decomposed the same way, except that the second step decrements instead of increments.</p>
<p>Suppose Thread A invokes <code>increment</code> at about the same time Thread B invokes <code>decrement</code>. If the initial value of <code>c</code> is <code>0</code>, their interleaved actions might follow this sequence:</p>
<ol>
<li>Thread A: Retrieve c.</li>
<li>Thread B: Retrieve c.</li>
<li>Thread A: Increment retrieved value; result is 1.</li>
<li>Thread B: Decrement retrieved value; result is -1.</li>
<li>Thread A: Store result in c; c is now 1.</li>
<li>Thread B: Store result in c; c is now -1.</li>
</ol>
<p>Thread A&apos;s result is lost, overwritten by Thread B. This particular interleaving is only one possibility. Under different circumstances it might be Thread B&apos;s result that gets lost, or there could be no error at all. Because they are unpredictable, thread interference bugs can be difficult to detect and fix.</p>

        </div><div id="PageTitle"><h1>Memory Consistency Errors</h1></div><div id="PageContent">

<p><i>Memory consistency errors</i> occur when different threads have inconsistent views of what should be the same data. The causes of memory consistency errors are complex and beyond the scope of this tutorial. Fortunately, the programmer does not need a detailed understanding of these causes. All that is needed is a strategy for avoiding them.</p>
<p>The key to avoiding memory consistency errors is understanding the <i>happens-before</i> relationship. This relationship is simply a guarantee that memory writes by one specific statement are visible to another specific statement. To see this, consider the following example. Suppose a simple <code>int</code> field is defined and initialized:</p>
<div class="codeblock"><pre>
int counter = 0;
</pre></div>
<p>The <code>counter</code> field is shared between two threads, A and B. Suppose thread A increments <code>counter</code>:</p>
<div class="codeblock"><pre>
counter++;
</pre></div>
<p>Then, shortly afterwards, thread B prints out <code>counter</code>:</p>
<div class="codeblock"><pre>
System.out.println(counter);
</pre></div>
<p>If the two statements had been executed in the same thread, it would be safe to assume that the value printed out would be &quot;1&quot;. But if the two statements are executed in separate threads, the value printed out might well be &quot;0&quot;, because there&apos;s no guarantee that thread A&apos;s change to <code>counter</code> will be visible to thread B &#x2014; unless the programmer has established a happens-before relationship between these two statements.</p>
<p>There are several actions that create happens-before relationships. One of them is synchronization, as we will see in the following sections.</p>
<p>We&apos;ve already seen two actions that create happens-before relationships.</p>
<ul>
<li>When a statement invokes <code>Thread.start</code>, every statement that has a happens-before relationship with that statement also has a happens-before relationship with every statement executed by the new thread. The effects of the code that led up to the creation of the new thread are visible to the new thread.</li>
<li>When a thread terminates and causes a <code>Thread.join</code> in another thread to return, then all the statements executed by the terminated thread have a happens-before relationship with all the statements following the successful join. The effects of the code in the thread are now visible to the thread that performed the join.</li>
</ul>
<p>For a list of actions that create happens-before relationships, refer to the 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html#MemoryVisibility">Summary page of the <code>java.util.concurrent</code> package.</a>.</p>

        </div><div id="PageTitle"><h1>Synchronized Methods</h1></div><div id="PageContent">

<p>The Java programming language provides two basic synchronization idioms: <i>synchronized methods</i> and <i>synchronized statements</i>. The more complex of the two, synchronized statements, are described in the next section. This section is about synchronized methods.</p>
<p>To make a method synchronized, simply add the <code>synchronized</code> keyword to its declaration:</p>
<div class="codeblock"><pre>
public class SynchronizedCounter {
    private int c = 0;

    public synchronized void increment() {
        c++;
    }

    public synchronized void decrement() {
        c--;
    }

    public synchronized int value() {
        return c;
    }
}
</pre></div>
<p>If <code>count</code> is an instance of <code>SynchronizedCounter</code>, then making these methods synchronized has two effects:</p>
<ul>
<li>First, it is not possible for two invocations of synchronized methods on the same object to interleave. When one thread is executing a synchronized method for an object, all other threads that invoke synchronized methods for the same object block (suspend execution) until the first thread is done with the object.</li>
<li>Second, when a synchronized method exits, it automatically establishes a happens-before relationship with <i>any subsequent invocation</i> of a synchronized method for the same object. This guarantees that changes to the state of the object are visible to all threads.</li>
</ul>
<p>Note that constructors cannot be synchronized &#x2014; using the <code>synchronized</code> keyword with a constructor is a syntax error. Synchronizing constructors doesn&apos;t make sense, because only the thread that creates an object should have access to it while it is being constructed.</p>
<div class="note"><hr><strong>Warning:</strong>&#xA0;When constructing an object that will be shared between threads, be very careful that a reference to the object does not &quot;leak&quot; prematurely. For example, suppose you want to maintain a <code>List</code> called <code>instances</code> containing every instance of class. You might be tempted to add the following line to your constructor:
<div class="codeblock"><pre>
instances.add(this);
</pre></div>
But then other threads can use <code>instances</code> to access the object before construction of the object is complete.
<hr></div>
<p>Synchronized methods enable a simple strategy for preventing thread interference and memory consistency errors: if an object is visible to more than one thread, all reads or writes to that object&apos;s variables are done through <code>synchronized</code> methods. (An important exception: <code>final</code> fields, which cannot be modified after the object is constructed, can be safely read through non-synchronized methods, once the object is constructed) This strategy is effective, but can present problems with <a href="liveness.html">liveness</a>, as we&apos;ll see later in this lesson.</p>

        </div><div id="PageTitle"><h1>Intrinsic Locks and Synchronization</h1></div><div id="PageContent">

<p>Synchronization is built around an internal entity known as the <i>intrinsic lock</i> or <i>monitor lock</i>. (The API specification often refers to this entity simply as a &quot;monitor.&quot;) Intrinsic locks play a role in both aspects of synchronization: enforcing exclusive access to an object&apos;s state and establishing happens-before relationships that are essential to visibility.</p>
<p>Every object has an intrinsic lock associated with it. By convention, a thread that needs exclusive and consistent access to an object&apos;s fields has to <i>acquire</i> the object&apos;s intrinsic lock before accessing them, and then <i>release</i> the intrinsic lock when it&apos;s done with them. A thread is said to <i>own</i> the intrinsic lock between the time it has acquired the lock and released the lock. As long as a thread owns an intrinsic lock, no other thread can acquire the same lock. The other thread will block when it attempts to acquire the lock.</p>
<p>When a thread releases an intrinsic lock, a happens-before relationship is established between that action and any subsequent acquisition of the same lock.</p>
<h2>Locks In Synchronized Methods</h2>
<p>When a thread invokes a synchronized method, it automatically acquires the intrinsic lock for that method&apos;s object and releases it when the method returns. The lock release occurs even if the return was caused by an uncaught exception.</p>
<p>You might wonder what happens when a static synchronized method is invoked, since a static method is associated with a class, not an object. In this case, the thread acquires the intrinsic lock for the <code>Class</code> object associated with the class. Thus access to class&apos;s static fields is controlled by a lock that&apos;s distinct from the lock for any instance of the class.</p>
<h2>Synchronized Statements</h2>
<p>Another way to create synchronized code is with <i>synchronized statements</i>. Unlike synchronized methods, synchronized statements must specify the object that provides the intrinsic lock:</p>
<div class="codeblock"><pre>
public void addName(String name) {
    synchronized(this) {
        lastName = name;
        nameCount++;
    }
    nameList.add(name);
}
</pre></div>
<p>In this example, the <code>addName</code> method needs to synchronize changes to <code>lastName</code> and <code>nameCount</code>, but also needs to avoid synchronizing invocations of other objects&apos; methods. (Invoking other objects&apos; methods from synchronized code can create problems that are described in the section on <a href="liveness.html">Liveness</a>.) Without synchronized statements, there would have to be a separate, unsynchronized method for the sole purpose of invoking <code>nameList.add</code>.</p>
<p>Synchronized statements are also useful for improving concurrency with fine-grained synchronization. Suppose, for example, class <code>MsLunch</code> has two instance fields, <code>c1</code> and <code>c2</code>, that are never used together. All updates of these fields must be synchronized, but there&apos;s no reason to prevent an update of c1 from being interleaved with an update of c2 &#x2014; and doing so reduces concurrency by creating unnecessary blocking. Instead of using synchronized methods or otherwise using the lock associated with <code>this</code>, we create two objects solely to provide locks.</p>
<div class="codeblock"><pre>
public class MsLunch {
    private long c1 = 0;
    private long c2 = 0;
    private Object lock1 = new Object();
    private Object lock2 = new Object();

    public void inc1() {
        synchronized(lock1) {
            c1++;
        }
    }

    public void inc2() {
        synchronized(lock2) {
            c2++;
        }
    }
}
</pre></div>
<p>Use this idiom with extreme care. You must be absolutely sure that it really is safe to interleave access of the affected fields.</p>
<h2>Reentrant Synchronization</h2>
<p>Recall that a thread cannot acquire a lock owned by another thread. But a thread <i>can</i> acquire a lock that it already owns. Allowing a thread to acquire the same lock more than once enables <i>reentrant synchronization</i>. This describes a situation where synchronized code, directly or indirectly, invokes a method that also contains synchronized code, and both sets of code use the same lock. Without reentrant synchronization, synchronized code would have to take many additional precautions to avoid having a thread cause itself to block.</p>

        </div><div id="PageTitle"><h1>Atomic Access</h1></div><div id="PageContent">

<p>In programming, an <i>atomic</i> action is one that effectively happens all at once. An atomic action cannot stop in the middle: it either happens completely, or it doesn&apos;t happen at all. No side effects of an atomic action are visible until the action is complete.</p>
<p>We have already seen that an increment expression, such as <code>c++</code>, does not describe an atomic action. Even very simple expressions can define complex actions that can decompose into other actions. However, there are actions you can specify that are atomic:</p>
<ul>
<li>Reads and writes are atomic for reference variables and for most primitive variables (all types except <code>long</code> and <code>double</code>).</li>
<li>Reads and writes are atomic for <i>all</i> variables declared <code>volatile</code> (<i>including</i> <code>long</code> and <code>double</code> variables).</li>
</ul>
<p>Atomic actions cannot be interleaved, so they can be used without fear of thread interference. However, this does not eliminate all need to synchronize atomic actions, because memory consistency errors are still possible. Using <code>volatile</code> variables reduces the risk of memory consistency errors, because any write to a <code>volatile</code> variable establishes a happens-before relationship with subsequent reads of that same variable. This means that changes to a <code>volatile</code> variable are always visible to other threads. What&apos;s more, it also means that when a thread reads a <code>volatile</code> variable, it sees not just the latest change to the <code>volatile</code>, but also the side effects of the code that led up the change.</p>
<p>Using simple atomic variable access is more efficient than accessing these variables through synchronized code, but requires more care by the programmer to avoid memory consistency errors. Whether the extra effort is worthwhile depends on the size and complexity of the application.</p>
<p>Some of the classes in the 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html"><code>java.util.concurrent</code></a> package provide atomic methods that do not rely on synchronization. We&apos;ll discuss them in the section on <a href="highlevel.html">High Level Concurrency Objects</a>.</p>

        </div><div id="PageTitle"><h1>Liveness</h1></div><div id="PageContent">

<p>A concurrent application&apos;s ability to execute in a timely manner is known as its <i>liveness</i>. This section describes the most common kind of liveness problem, <a href="deadlock.html">deadlock</a>, and goes on to briefly describe two other liveness problems, <a href="starvelive.html">starvation and livelock</a>.</p>

        </div><div id="PageTitle"><h1>Deadlock</h1></div><div id="PageContent">

<p><i>Deadlock</i> describes a situation where two or more threads are blocked forever, waiting for each other. Here&apos;s an example.</p>
<p>Alphonse and Gaston are friends, and great believers in courtesy. A strict rule of courtesy is that when you bow to a friend, you must remain bowed until your friend has a chance to return the bow. Unfortunately, this rule does not account for the possibility that two friends might bow to each other at the same time. This example application, 
<a class="SourceLink" target="_blank" href="examples/Deadlock.java" onclick="showCode(&apos;../../displayCode.html&apos;, &apos;examples/Deadlock.java&apos;); return false;"><code><code>Deadlock</code></code></a>, models this possibility:</p>
<div class="codeblock"><pre>

public class Deadlock {
    static class Friend {
        private final String name;
        public Friend(String name) {
            this.name = name;
        }
        public String getName() {
            return this.name;
        }
        public synchronized void bow(Friend bower) {
            System.out.format(&quot;%s: %s&quot;
                + &quot;  has bowed to me!%n&quot;, 
                this.name, bower.getName());
            bower.bowBack(this);
        }
        public synchronized void bowBack(Friend bower) {
            System.out.format(&quot;%s: %s&quot;
                + &quot; has bowed back to me!%n&quot;,
                this.name, bower.getName());
        }
    }

    public static void main(String[] args) {
        final Friend alphonse =
            new Friend(&quot;Alphonse&quot;);
        final Friend gaston =
            new Friend(&quot;Gaston&quot;);
        new Thread(new Runnable() {
            public void run() { alphonse.bow(gaston); }
        }).start();
        new Thread(new Runnable() {
            public void run() { gaston.bow(alphonse); }
        }).start();
    }
}
</pre></div>
<p>When <code>Deadlock</code> runs, it&apos;s extremely likely that both threads will block when they attempt to invoke <code>bowBack</code>. Neither block will ever end, because each thread is waiting for the other to exit <code>bow</code>.</p>

        </div><div id="PageTitle"><h1>Starvation and Livelock</h1></div><div id="PageContent">

<p>Starvation and livelock are much less common a problem than deadlock, but are still problems that every designer of concurrent software is likely to encounter.</p>
<h2>Starvation</h2>
<p><i>Starvation</i> describes a situation where a thread is unable to gain regular access to shared resources and is unable to make progress. This happens when shared resources are made unavailable for long periods by &quot;greedy&quot; threads. For example, suppose an object provides a synchronized method that often takes a long time to return. If one thread invokes this method frequently, other threads that also need frequent synchronized access to the same object will often be blocked.</p>
<h2>Livelock</h2>
<p>A thread often acts in response to the action of another thread. If the other thread&apos;s action is also a response to the action of another thread, then <i>livelock</i> may result. As with deadlock, livelocked threads are unable to make further progress. However, the threads are not blocked &#x2014; they are simply too busy responding to each other to resume work. This is comparable to two people attempting to pass each other in a corridor: Alphonse moves to his left to let Gaston pass, while Gaston moves to his right to let Alphonse pass. Seeing that they are still blocking each other, Alphone moves to his right, while Gaston moves to his left. They&apos;re still blocking each other, so...</p>


        </div><div id="PageTitle"><h1>Guarded Blocks</h1></div><div id="PageContent">

<p>Threads often have to coordinate their actions. The most common coordination idiom is the <i>guarded block</i>. Such a block begins by polling a condition that must be true before the block can proceed. There are a number of steps to follow in order to do this correctly.</p>
<p>Suppose, for example <code>guardedJoy</code> is a method that must not proceed until a shared variable <code>joy</code> has been set by another thread. Such a method could, in theory, simply loop until the condition is satisfied, but that loop is wasteful, since it executes continuously while waiting.</p>
<div class="codeblock"><pre>
public void guardedJoy() {
    // Simple loop guard. Wastes
    // processor time. Don&apos;t do this!
    while(!joy) {}
    System.out.println(&quot;Joy has been achieved!&quot;);
}
</pre></div>
<p>A more efficient guard invokes 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait--"><code>Object.wait</code></a> to suspend the current thread. The invocation of <code>wait</code> does not return until another thread has issued a notification that some special event may have occurred &#x2014; though not necessarily the event this thread is waiting for:</p>
<div class="codeblock"><pre>
public synchronized void guardedJoy() {
    // This guard only loops once for each special event, which may not
    // be the event we&apos;re waiting for.
    while(!joy) {
        try {
            wait();
        } catch (InterruptedException e) {}
    }
    System.out.println(&quot;Joy and efficiency have been achieved!&quot;);
}
</pre></div>
<div class="note"><hr><strong>Note:</strong>&#xA0;Always invoke <code>wait</code> inside a loop that tests for the condition being waited for. Don&apos;t assume that the interrupt was for the particular condition you were waiting for, or that the condition is still true.
<hr></div>
<p>Like many methods that suspend execution, <code>wait</code> can throw <code>InterruptedException</code>. In this example, we can just ignore that exception &#x2014; we only care about the value of <code>joy</code>.</p>
<p>Why is this version of <code>guardedJoy</code> synchronized? Suppose <code>d</code> is the object we&apos;re using to invoke <code>wait</code>. When a thread invokes <code>d.wait</code>, it must own the intrinsic lock for <code>d</code> &#x2014; otherwise an error is thrown. Invoking <code>wait</code> inside a synchronized method is a simple way to acquire the intrinsic lock.</p>
<p>When <code>wait</code> is invoked, the thread releases the lock and suspends execution. At some future time, another thread will acquire the same lock and invoke 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notifyAll--"><code>Object.notifyAll</code></a>, informing all threads waiting on that lock that something important has happened:</p>
<div class="codeblock"><pre>
public synchronized notifyJoy() {
    joy = true;
    notifyAll();
}
</pre></div>
<p>Some time after the second thread has released the lock, the first thread reacquires the lock and resumes by returning from the invocation of <code>wait</code>.</p>
<div class="note"><hr><strong>Note:</strong>&#xA0;There is a second notification method, <code>notify</code>, which wakes up a single thread. Because <code>notify</code> doesn&apos;t allow you to specify the thread that is woken up, it is useful only in massively parallel applications &#x2014; that is, programs with a large number of threads, all doing similar chores. In such an application, you don&apos;t care which thread gets woken up.
<hr></div>
<p>Let&apos;s use guarded blocks to create a <i>Producer-Consumer</i> application. This kind of application shares data between two threads: the <i>producer</i>, that creates the data, and the <i>consumer</i>, that does something with it. The two threads communicate using a shared object. Coordination is essential: the consumer thread must not attempt to retrieve the data before the producer thread has delivered it, and the producer thread must not attempt to deliver new data if the consumer hasn&apos;t retrieved the old data.</p>
<p>In this example, the data is a series of text messages, which are shared through an object of type 
<a class="SourceLink" target="_blank" href="examples/Drop.java" onclick="showCode(&apos;../../displayCode.html&apos;, &apos;examples/Drop.java&apos;); return false;"><code><code>Drop</code></code></a>:</p>
<div class="codeblock"><pre>

public class Drop {
    // Message sent from producer
    // to consumer.
    private String message;
    // True if consumer should wait
    // for producer to send message,
    // false if producer should wait for
    // consumer to retrieve message.
    private boolean empty = true;

    public synchronized String take() {
        // Wait until message is
        // available.
        while (empty) {
            try {
                wait();
            } catch (InterruptedException e) {}
        }
        // Toggle status.
        empty = true;
        // Notify producer that
        // status has changed.
        notifyAll();
        return message;
    }

    public synchronized void put(String message) {
        // Wait until message has
        // been retrieved.
        while (!empty) {
            try { 
                wait();
            } catch (InterruptedException e) {}
        }
        // Toggle status.
        empty = false;
        // Store message.
        this.message = message;
        // Notify consumer that status
        // has changed.
        notifyAll();
    }
}
</pre></div>
<p>The producer thread, defined in 
<a class="SourceLink" target="_blank" href="examples/Producer.java" onclick="showCode(&apos;../../displayCode.html&apos;, &apos;examples/Producer.java&apos;); return false;"><code><code>Producer</code></code></a>, sends a series of familiar messages. The string &quot;DONE&quot; indicates that all messages have been sent. To simulate the unpredictable nature of real-world applications, the producer thread pauses for random intervals between messages.</p>
<div class="codeblock"><pre>

import java.util.Random;

public class Producer implements Runnable {
    private Drop drop;

    public Producer(Drop drop) {
        this.drop = drop;
    }

    public void run() {
        String importantInfo[] = {
            &quot;Mares eat oats&quot;,
            &quot;Does eat oats&quot;,
            &quot;Little lambs eat ivy&quot;,
            &quot;A kid will eat ivy too&quot;
        };
        Random random = new Random();

        for (int i = 0;
             i &lt; importantInfo.length;
             i++) {
            drop.put(importantInfo[i]);
            try {
                Thread.sleep(random.nextInt(5000));
            } catch (InterruptedException e) {}
        }
        drop.put(&quot;DONE&quot;);
    }
}
</pre></div>
<p>The consumer thread, defined in 
<a class="SourceLink" target="_blank" href="examples/Consumer.java" onclick="showCode(&apos;../../displayCode.html&apos;, &apos;examples/Consumer.java&apos;); return false;"><code><code>Consumer</code></code></a>, simply retrieves the messages and prints them out, until it retrieves the &quot;DONE&quot; string. This thread also pauses for random intervals.</p>
<div class="codeblock"><pre>

import java.util.Random;

public class Consumer implements Runnable {
    private Drop drop;

    public Consumer(Drop drop) {
        this.drop = drop;
    }

    public void run() {
        Random random = new Random();
        for (String message = drop.take();
             ! message.equals(&quot;DONE&quot;);
             message = drop.take()) {
            System.out.format(&quot;MESSAGE RECEIVED: %s%n&quot;, message);
            try {
                Thread.sleep(random.nextInt(5000));
            } catch (InterruptedException e) {}
        }
    }
}
</pre></div>
<p>Finally, here is the main thread, defined in 
<a class="SourceLink" target="_blank" href="examples/ProducerConsumerExample.java" onclick="showCode(&apos;../../displayCode.html&apos;, &apos;examples/ProducerConsumerExample.java&apos;); return false;"><code><code>ProducerConsumerExample</code></code></a>, that launches the producer and consumer threads.</p>
<div class="codeblock"><pre>

public class ProducerConsumerExample {
    public static void main(String[] args) {
        Drop drop = new Drop();
        (new Thread(new Producer(drop))).start();
        (new Thread(new Consumer(drop))).start();
    }
}
</pre></div>
<div class="note"><hr><strong>Note:</strong>&#xA0;The <code>Drop</code> class was written in order to demonstrate guarded blocks. To avoid re-inventing the wheel, examine the existing data structures in the 
<a class="TutorialLink" target="_top" href="../../collections/index.html">Java Collections Framework</a> before trying to code your own data-sharing objects. For more information, refer to the <a href="QandE/questions.html">Questions and Exercises</a> section.
<hr></div>

        </div><div id="PageTitle"><h1>Immutable Objects</h1></div><div id="PageContent">

<p>An object is considered <i>immutable</i> if its state cannot change after it is constructed. Maximum reliance on immutable objects is widely accepted as a sound strategy for creating simple, reliable code.</p>
<p>Immutable objects are particularly useful in concurrent applications. Since they cannot change state, they cannot be corrupted by thread interference or observed in an inconsistent state.</p>
<p>Programmers are often reluctant to employ immutable objects, because they worry about the cost of creating a new object as opposed to updating an object in place. The impact of object creation is often overestimated, and can be offset by some of the efficiencies associated with immutable objects. These include decreased overhead due to garbage collection, and the elimination of code needed to protect mutable objects from corruption.</p>
<p>The following subsections take a class whose instances are mutable and derives a class with immutable instances from it. In so doing, they give general rules for this kind of conversion and demonstrate some of the advantages of immutable objects.</p>


        </div><div id="PageTitle"><h1>A Synchronized Class Example</h1></div><div id="PageContent">

<p>The class, 
<a class="SourceLink" target="_blank" href="examples/SynchronizedRGB.java" onclick="showCode(&apos;../../displayCode.html&apos;, &apos;examples/SynchronizedRGB.java&apos;); return false;"><code><code>SynchronizedRGB</code></code></a>, defines objects that represent colors. Each object represents the color as three integers that stand for primary color values and a string that gives the name of the color.</p>
<div class="codeblock"><pre>

public class SynchronizedRGB {

    // Values must be between 0 and 255.
    private int red;
    private int green;
    private int blue;
    private String name;

    private void check(int red,
                       int green,
                       int blue) {
        if (red &lt; 0 || red &gt; 255
            || green &lt; 0 || green &gt; 255
            || blue &lt; 0 || blue &gt; 255) {
            throw new IllegalArgumentException();
        }
    }

    public SynchronizedRGB(int red,
                           int green,
                           int blue,
                           String name) {
        check(red, green, blue);
        this.red = red;
        this.green = green;
        this.blue = blue;
        this.name = name;
    }

    public void set(int red,
                    int green,
                    int blue,
                    String name) {
        check(red, green, blue);
        synchronized (this) {
            this.red = red;
            this.green = green;
            this.blue = blue;
            this.name = name;
        }
    }

    public synchronized int getRGB() {
        return ((red &lt;&lt; 16) | (green &lt;&lt; 8) | blue);
    }

    public synchronized String getName() {
        return name;
    }

    public synchronized void invert() {
        red = 255 - red;
        green = 255 - green;
        blue = 255 - blue;
        name = &quot;Inverse of &quot; + name;
    }
}
</pre></div>
<p><code>SynchronizedRGB</code> must be used carefully to avoid being seen in an inconsistent state. Suppose, for example, a thread executes the following code:</p>
<div class="codeblock"><pre>
SynchronizedRGB color =
    new SynchronizedRGB(0, 0, 0, &quot;Pitch Black&quot;);
...
int myColorInt = color.getRGB();      //Statement 1
String myColorName = color.getName(); //Statement 2
</pre></div>
<p>If another thread invokes <code>color.set</code> after Statement 1 but before Statement 2, the value of <code>myColorInt</code> won&apos;t match the value of <code>myColorName</code>. To avoid this outcome, the two statements must be bound together:</p>
<div class="codeblock"><pre>
synchronized (color) {
    int myColorInt = color.getRGB();
    String myColorName = color.getName();
} 
</pre></div>
<p>This kind of inconsistency is only possible for mutable objects &#x2014; it will not be an issue for the immutable version of <code>SynchronizedRGB</code>.</p>

        </div><div id="PageTitle"><h1>A Strategy for Defining Immutable Objects</h1></div><div id="PageContent">

<p>The following rules define a simple strategy for creating immutable objects. Not all classes documented as &quot;immutable&quot; follow these rules. This does not necessarily mean the creators of these classes were sloppy &#x2014; they may have good reason for believing that instances of their classes never change after construction. However, such strategies require sophisticated analysis and are not for beginners.</p>
<ol>
<li>Don&apos;t provide &quot;setter&quot; methods &#x2014; methods that modify fields or objects referred to by fields.</li>
<li>Make all fields <code>final</code> and <code>private</code>.</li>
<li>Don&apos;t allow subclasses to override methods. The simplest way to do this is to declare the class as <code>final</code>. A more sophisticated approach is to make the constructor <code>private</code> and construct instances in factory methods.</li>
<li>If the instance fields include references to mutable objects, don&apos;t allow those objects to be changed:
<ul>
<li>Don&apos;t provide methods that modify the mutable objects.</li>
<li>Don&apos;t share references to the mutable objects. Never store references to external, mutable objects passed to the constructor; if necessary, create copies, and store references to the copies. Similarly, create copies of your internal mutable objects when necessary to avoid returning the originals in your methods.</li>
</ul>
</li>
</ol>
<p>Applying this strategy to <code>SynchronizedRGB</code> results in the following steps:</p>
<ol>
<li>There are two setter methods in this class. The first one, <code>set</code>, arbitrarily transforms the object, and has no place in an immutable version of the class. The second one, <code>invert</code>, can be adapted by having it create a new object instead of modifying the existing one.</li>
<li>All fields are already <code>private</code>; they are further qualified as <code>final</code>.</li>
<li>The class itself is declared <code>final</code>.</li>
<li>Only one field refers to an object, and that object is itself immutable. Therefore, no safeguards against changing the state of &quot;contained&quot; mutable objects are necessary.</li>
</ol>
<p>After these changes, we have 
<a class="SourceLink" target="_blank" href="examples/ImmutableRGB.java" onclick="showCode(&apos;../../displayCode.html&apos;, &apos;examples/ImmutableRGB.java&apos;); return false;"><code><code>ImmutableRGB</code></code></a>:</p>
<div class="codeblock"><pre>

final public class ImmutableRGB {

    // Values must be between 0 and 255.
    final private int red;
    final private int green;
    final private int blue;
    final private String name;

    private void check(int red,
                       int green,
                       int blue) {
        if (red &lt; 0 || red &gt; 255
            || green &lt; 0 || green &gt; 255
            || blue &lt; 0 || blue &gt; 255) {
            throw new IllegalArgumentException();
        }
    }

    public ImmutableRGB(int red,
                        int green,
                        int blue,
                        String name) {
        check(red, green, blue);
        this.red = red;
        this.green = green;
        this.blue = blue;
        this.name = name;
    }


    public int getRGB() {
        return ((red &lt;&lt; 16) | (green &lt;&lt; 8) | blue);
    }

    public String getName() {
        return name;
    }

    public ImmutableRGB invert() {
        return new ImmutableRGB(255 - red,
                       255 - green,
                       255 - blue,
                       &quot;Inverse of &quot; + name);
    }
}
</pre></div>

        </div><div id="PageTitle"><h1>High Level Concurrency Objects</h1></div><div id="PageContent">

<p>So far, this lesson has focused on the low-level APIs that have been part of the Java platform from the very beginning. These APIs are adequate for very basic tasks, but higher-level building blocks are needed for more advanced tasks. This is especially true for massively concurrent applications that fully exploit today&apos;s multiprocessor and multi-core systems.</p>
<p>In this section we&apos;ll look at some of the high-level concurrency features introduced with version 5.0 of the Java platform. Most of these features are implemented in the new <code>java.util.concurrent</code> packages. There are also new concurrent data structures in the Java Collections Framework.</p>
<ul>
<li><a href="newlocks.html">Lock objects</a> support locking idioms that simplify many concurrent applications.</li>
<li><a href="executors.html">Executors</a> define a high-level API for launching and managing threads. Executor implementations provided by <code>java.util.concurrent</code> provide thread pool management suitable for large-scale applications.</li>
<li><a href="collections.html">Concurrent collections</a> make it easier to manage large collections of data, and can greatly reduce the need for synchronization.</li>
<li><a href="atomicvars.html">Atomic variables</a> have features that minimize synchronization and help avoid memory consistency errors.</li>
<li><a href="threadlocalrandom.html"><code>ThreadLocalRandom</code></a> (in JDK 7) provides efficient generation of pseudorandom numbers from multiple threads.</li>
</ul>


        </div><div id="PageTitle"><h1>Lock Objects</h1></div><div id="PageContent">

<p>Synchronized code relies on a simple kind of reentrant lock. This kind of lock is easy to use, but has many limitations. More sophisticated locking idioms are supported by the 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/package-summary.html"><code>java.util.concurrent.locks</code></a> package. We won&apos;t examine this package in detail, but instead will focus on its most basic interface, 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html"><code>Lock</code></a>.</p>
<p><code>Lock</code> objects work very much like the implicit locks used by synchronized code. As with implicit locks, only one thread can own a <code>Lock</code> object at a time. <code>Lock</code> objects also support a <code>wait/notify</code> mechanism, through their associated 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Condition.html"><code>Condition</code></a> objects.</p>
<p>The biggest advantage of <code>Lock</code> objects over implicit locks is their ability to back out of an attempt to acquire a lock. The <code>tryLock</code> method backs out if the lock is not available immediately or before a timeout expires (if specified). The <code>lockInterruptibly</code> method backs out if another thread sends an interrupt before the lock is acquired.</p>
<p>Let&apos;s use <code>Lock</code> objects to solve the deadlock problem we saw in <a href="liveness.html">Liveness</a>. Alphonse and Gaston have trained themselves to notice when a friend is about to bow. We model this improvement by requiring that our <code>Friend</code> objects must acquire locks for <i>both</i> participants before proceeding with the bow. Here is the source code for the improved model, 
<a class="SourceLink" target="_blank" href="examples/Safelock.java" onclick="showCode(&apos;../../displayCode.html&apos;, &apos;examples/Safelock.java&apos;); return false;"><code><code>Safelock</code></code></a>. To demonstrate the versatility of this idiom, we assume that Alphonse and Gaston are so infatuated with their newfound ability to bow safely that they can&apos;t stop bowing to each other:</p>
<div class="codeblock"><pre>

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.Random;

public class Safelock {
    static class Friend {
        private final String name;
        private final Lock lock = new ReentrantLock();

        public Friend(String name) {
            this.name = name;
        }

        public String getName() {
            return this.name;
        }

        public boolean impendingBow(Friend bower) {
            Boolean myLock = false;
            Boolean yourLock = false;
            try {
                myLock = lock.tryLock();
                yourLock = bower.lock.tryLock();
            } finally {
                if (! (myLock &amp;&amp; yourLock)) {
                    if (myLock) {
                        lock.unlock();
                    }
                    if (yourLock) {
                        bower.lock.unlock();
                    }
                }
            }
            return myLock &amp;&amp; yourLock;
        }
            
        public void bow(Friend bower) {
            if (impendingBow(bower)) {
                try {
                    System.out.format(&quot;%s: %s has&quot;
                        + &quot; bowed to me!%n&quot;, 
                        this.name, bower.getName());
                    bower.bowBack(this);
                } finally {
                    lock.unlock();
                    bower.lock.unlock();
                }
            } else {
                System.out.format(&quot;%s: %s started&quot;
                    + &quot; to bow to me, but saw that&quot;
                    + &quot; I was already bowing to&quot;
                    + &quot; him.%n&quot;,
                    this.name, bower.getName());
            }
        }

        public void bowBack(Friend bower) {
            System.out.format(&quot;%s: %s has&quot; +
                &quot; bowed back to me!%n&quot;,
                this.name, bower.getName());
        }
    }

    static class BowLoop implements Runnable {
        private Friend bower;
        private Friend bowee;

        public BowLoop(Friend bower, Friend bowee) {
            this.bower = bower;
            this.bowee = bowee;
        }
    
        public void run() {
            Random random = new Random();
            for (;;) {
                try {
                    Thread.sleep(random.nextInt(10));
                } catch (InterruptedException e) {}
                bowee.bow(bower);
            }
        }
    }
            

    public static void main(String[] args) {
        final Friend alphonse =
            new Friend(&quot;Alphonse&quot;);
        final Friend gaston =
            new Friend(&quot;Gaston&quot;);
        new Thread(new BowLoop(alphonse, gaston)).start();
        new Thread(new BowLoop(gaston, alphonse)).start();
    }
}
</pre></div>

        </div><div id="PageTitle"><h1>Executors</h1></div><div id="PageContent">

<p>In all of the previous examples, there&apos;s a close connection between the task being done by a new thread, as defined by its <code>Runnable</code> object, and the thread itself, as defined by a <code>Thread</code> object. This works well for small applications, but in large-scale applications, it makes sense to separate thread management and creation from the rest of the application. Objects that encapsulate these functions are known as <i>executors</i>. The following subsections describe executors in detail.</p>
<ul>
<li><a href="exinter.html">Executor Interfaces</a> define the three executor object types.</li>
<li><a href="pools.html">Thread Pools</a> are the most common kind of executor implementation.</li>
<li><a href="forkjoin.html">Fork/Join</a> is a framework (new in JDK 7) for taking advantage of multiple processors.</li>
</ul>


        </div><div id="PageTitle"><h1>Executor Interfaces</h1></div><div id="PageContent">

<p>The <code>java.util.concurrent</code> package defines three executor interfaces:</p>
<ul>
<li><code>Executor</code>, a simple interface that supports launching new tasks.</li>
<li><code>ExecutorService</code>, a subinterface of <code>Executor</code>, which adds features that help manage the lifecycle, both of the individual tasks and of the executor itself.</li>
<li><code>ScheduledExecutorService</code>, a subinterface of <code>ExecutorService</code>, supports future and/or periodic execution of tasks.</li>
</ul>
<p>Typically, variables that refer to executor objects are declared as one of these three interface types, not with an executor class type.</p>
<h2>The <code>Executor</code> Interface</h2>
<p>The 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html"><code>Executor</code></a> interface provides a single method, <code>execute</code>, designed to be a drop-in replacement for a common thread-creation idiom. If <code>r</code> is a <code>Runnable</code> object, and <code>e</code> is an <code>Executor</code> object you can replace</p>
<div class="codeblock"><pre>
(new Thread(r)).start();
</pre></div>
<p>with</p>
<div class="codeblock"><pre>
e.execute(r);
</pre></div>
<p>However, the definition of <code>execute</code> is less specific. The low-level idiom creates a new thread and launches it immediately. Depending on the <code>Executor</code> implementation, <code>execute</code> may do the same thing, but is more likely to use an existing worker thread to run <code>r</code>, or to place <code>r</code> in a queue to wait for a worker thread to become available. (We&apos;ll describe worker threads in the section on <a href="pools.html">Thread Pools</a>.)</p>
<p>The executor implementations in <code>java.util.concurrent</code> are designed to make full use of the more advanced <code>ExecutorService</code> and <code>ScheduledExecutorService</code> interfaces, although they also work with the base <code>Executor</code> interface.</p>
<h2>The <code>ExecutorService</code> Interface</h2>
<p>The 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html"><code>ExecutorService</code></a> interface supplements <code>execute</code> with a similar, but more versatile <code>submit</code> method. Like <code>execute</code>, <code>submit</code> accepts <code>Runnable</code> objects, but also accepts 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Callable.html"><code>Callable</code></a> objects, which allow the task to return a value. The <code>submit</code> method returns a 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html"><code>Future</code></a> object, which is used to retrieve the <code>Callable</code> return value and to manage the status of both <code>Callable</code> and <code>Runnable</code> tasks.</p>
<p><code>ExecutorService</code> also provides methods for submitting large collections of <code>Callable</code> objects. Finally, <code>ExecutorService</code> provides a number of methods for managing the shutdown of the executor. To support immediate shutdown, tasks should handle <a href="interrupt.html">interrupts</a> correctly.</p>
<h2>The <code>ScheduledExecutorService</code> Interface</h2>
<p>The 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html"><code>ScheduledExecutorService</code></a> interface supplements the methods of its parent <code>ExecutorService</code> with <code>schedule</code>, which executes a <code>Runnable</code> or <code>Callable</code> task after a specified delay. In addition, the interface defines <code>scheduleAtFixedRate</code> and <code>scheduleWithFixedDelay</code>, which executes specified tasks repeatedly, at defined intervals.</p>

        </div><div id="PageTitle"><h1>Thread Pools</h1></div><div id="PageContent">

<p>Most of the executor implementations in <code>java.util.concurrent</code> use <i>thread pools</i>, which consist of <i>worker threads</i>. This kind of thread exists separately from the <code>Runnable</code> and <code>Callable</code> tasks it executes and is often used to execute multiple tasks.</p>
<p>Using worker threads minimizes the overhead due to thread creation. Thread objects use a significant amount of memory, and in a large-scale application, allocating and deallocating many thread objects creates a significant memory management overhead.</p>
<p>One common type of thread pool is the <i>fixed thread pool</i>. This type of pool always has a specified number of threads running; if a thread is somehow terminated while it is still in use, it is automatically replaced with a new thread. Tasks are submitted to the pool via an internal queue, which holds extra tasks whenever there are more active tasks than threads.</p>
<p>An important advantage of the fixed thread pool is that applications using it <i>degrade gracefully</i>. To understand this, consider a web server application where each HTTP request is handled by a separate thread. If the application simply creates a new thread for every new HTTP request, and the system receives more requests than it can handle immediately, the application will suddenly stop responding to <i>all</i> requests when the overhead of all those threads exceed the capacity of the system. With a limit on the number of the threads that can be created, the application will not be servicing HTTP requests as quickly as they come in, but it will be servicing them as quickly as the system can sustain.</p>
<p>A simple way to create an executor that uses a fixed thread pool is to invoke the 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html#newFixedThreadPool-int-"><code>newFixedThreadPool</code></a> factory method in 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html"><code>java.util.concurrent.Executors</code></a> This class also provides the following factory methods:</p>
<ul>
<li>The 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html#newCachedThreadPool-int-"><code>newCachedThreadPool</code></a> method creates an executor with an expandable thread pool. This executor is suitable for applications that launch many short-lived tasks.</li>
<li>The 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html#newSingleThreadExecutor-int-"><code>newSingleThreadExecutor</code></a> method creates an executor that executes a single task at a time.</li>
<li>Several factory methods are <code>ScheduledExecutorService</code> versions of the above executors.</li>
</ul>
<p>If none of the executors provided by the above factory methods meet your needs, constructing instances of 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadPoolExecutor.html"><code>java.util.concurrent.ThreadPoolExecutor</code></a> or 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html"><code>java.util.concurrent.ScheduledThreadPoolExecutor</code></a> will give you additional options.</p>

        </div><div id="PageTitle"><h1>Fork/Join</h1></div><div id="PageContent">

<p>The fork/join framework is an implementation of the <code>ExecutorService</code> interface that helps you take advantage of multiple processors. It is designed for work that can be broken into smaller pieces recursively. The goal is to use all the available processing power to enhance the performance of your application.</p>
<p>As with any <code>ExecutorService</code> implementation, the fork/join framework distributes tasks to worker threads in a thread pool. The fork/join framework is distinct because it uses a <i>work-stealing</i> algorithm. Worker threads that run out of things to do can steal tasks from other threads that are still busy.</p>
<p>The center of the fork/join framework is the 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html"><code>ForkJoinPool</code></a> class, an extension of the <code>AbstractExecutorService</code> class. <code>ForkJoinPool</code> implements the core work-stealing algorithm and can execute 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinTask.html"><code>ForkJoinTask</code></a> processes.</p>
<h2>Basic Use</h2>
<p>The first step for using the fork/join framework is to write code that performs a segment of the work. Your code should look similar to the following pseudocode:</p>
<div class="codeblock"><pre>
if (my portion of the work is small enough)
  do the work directly
else
  split my work into two pieces
  invoke the two pieces and wait for the results
</pre></div>
<p>Wrap this code in a <code>ForkJoinTask</code> subclass, typically using one of its more specialized types, either 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/RecursiveTask.html"><code>RecursiveTask</code></a> (which can return a result) or 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/RecursiveAction.html"><code>RecursiveAction</code></a>.</p>
<p>After your <code>ForkJoinTask</code> subclass is ready, create the object that represents all the work to be done and pass it to the <code>invoke()</code> method of a <code>ForkJoinPool</code> instance.</p>
<h2>Blurring for Clarity</h2>
<p>To help you understand how the fork/join framework works, consider the following example. Suppose that you want to blur an image. The original <i>source</i> image is represented by an array of integers, where each integer contains the color values for a single pixel. The blurred <i>destination</i> image is also represented by an integer array with the same size as the source.</p>
<p>Performing the blur is accomplished by working through the source array one pixel at a time. Each pixel is averaged with its surrounding pixels (the red, green, and blue components are averaged), and the result is placed in the destination array. Since an image is a large array, this process can take a long time. You can take advantage of concurrent processing on multiprocessor systems by implementing the algorithm using the fork/join framework. Here is one possible implementation:</p>
<div class="codeblock"><pre>
public class ForkBlur extends RecursiveAction {
    private int[] mSource;
    private int mStart;
    private int mLength;
    private int[] mDestination;
  
    // Processing window size; should be odd.
    private int mBlurWidth = 15;
  
    public ForkBlur(int[] src, int start, int length, int[] dst) {
        mSource = src;
        mStart = start;
        mLength = length;
        mDestination = dst;
    }

    protected void computeDirectly() {
        int sidePixels = (mBlurWidth - 1) / 2;
        for (int index = mStart; index &lt; mStart + mLength; index++) {
            // Calculate average.
            float rt = 0, gt = 0, bt = 0;
            for (int mi = -sidePixels; mi &lt;= sidePixels; mi++) {
                int mindex = Math.min(Math.max(mi + index, 0),
                                    mSource.length - 1);
                int pixel = mSource[mindex];
                rt += (float)((pixel &amp; 0x00ff0000) &gt;&gt; 16)
                      / mBlurWidth;
                gt += (float)((pixel &amp; 0x0000ff00) &gt;&gt;  8)
                      / mBlurWidth;
                bt += (float)((pixel &amp; 0x000000ff) &gt;&gt;  0)
                      / mBlurWidth;
            }
          
            // Reassemble destination pixel.
            int dpixel = (0xff000000     ) |
                   (((int)rt) &lt;&lt; 16) |
                   (((int)gt) &lt;&lt;  8) |
                   (((int)bt) &lt;&lt;  0);
            mDestination[index] = dpixel;
        }
    }
  
  ...
</pre></div>
<p>Now you implement the abstract <code>compute()</code> method, which either performs the blur directly or splits it into two smaller tasks. A simple array length threshold helps determine whether the work is performed or split.</p>
<div class="codeblock"><pre>
protected static int sThreshold = 100000;

protected void compute() {
    if (mLength &lt; sThreshold) {
        computeDirectly();
        return;
    }
    
    int split = mLength / 2;
    
    invokeAll(new ForkBlur(mSource, mStart, split, mDestination),
              new ForkBlur(mSource, mStart + split, mLength - split,
                           mDestination));
}
</pre></div>
<p>If the previous methods are in a subclass of the <code>RecursiveAction</code> class, then setting up the task to run in a <code>ForkJoinPool</code> is straightforward, and involves the following steps:</p>
<ol>
<li><p>Create a task that represents all of the work to be done.</p>
<div class="codeblock"><pre>
// source image pixels are in src
// destination image pixels are in dst
ForkBlur fb = new ForkBlur(src, 0, src.length, dst);
</pre></div>
</li>
<li><p>Create the <code>ForkJoinPool</code> that will run the task.</p>
<div class="codeblock"><pre>
ForkJoinPool pool = new ForkJoinPool();
</pre></div>
</li>
<li><p>Run the task.</p>
<div class="codeblock"><pre>
pool.invoke(fb);
</pre></div>
</li>
</ol>
<p>For the full source code, including some extra code that creates the destination image file, see the 
<a class="SourceLink" target="_blank" href="examples/ForkBlur.java" onclick="showCode(&apos;../../displayCode.html&apos;, &apos;examples/ForkBlur.java&apos;); return false;"><code><code>ForkBlur</code></code></a> example.</p>
<h2>Standard Implementations</h2>
<p>Besides using the fork/join framework to implement custom algorithms for tasks to be performed concurrently on a multiprocessor system (such as the <code>ForkBlur.java</code> example in the previous section), there are some generally useful features in Java SE which are already implemented using the fork/join framework. One such implementation, introduced in Java SE 8, is used by the 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html"><code>java.util.Arrays</code></a> class for its <code>parallelSort()</code> methods. These methods are similar to <code>sort()</code>, but leverage concurrency via the fork/join framework. Parallel sorting of large arrays is faster than sequential sorting when run on multiprocessor systems. However, how exactly the fork/join framework is leveraged by these methods is outside the scope of the Java Tutorials. For this information, see the Java API documentation.</p>
 <p>Another implementation of the fork/join framework is used by methods in the <code>java.util.streams</code> package, which is part of 
<a class="OutsideLink" target="_blank" href="http://openjdk.java.net/projects/lambda/">Project Lambda</a> scheduled for the Java SE 8 release. For more information, see the  
<a class="TutorialLink" target="_top" href="../../java/javaOO/lambdaexpressions.html">Lambda Expressions</a> section.</p>
        </div><div id="PageTitle"><h1>Concurrent Collections</h1></div><div id="PageContent">

<p>The <code>java.util.concurrent</code> package includes a number of additions to the Java Collections Framework. These are most easily categorized by the collection interfaces provided:</p>
<ul>
<li>
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html"><code>BlockingQueue</code></a> defines a first-in-first-out data structure that blocks or times out when you attempt to add to a full queue, or retrieve from an empty queue.</li>
<li>
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html"><code>ConcurrentMap</code></a> is a subinterface of 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html"><code>java.util.Map</code></a> that defines useful atomic operations. These operations remove or replace a key-value pair only if the key is present, or add a key-value pair only if the key is absent. Making these operations atomic helps avoid synchronization. The standard general-purpose implementation of <code>ConcurrentMap</code> is 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html"><code>ConcurrentHashMap</code></a>, which is a concurrent analog of 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html"><code>HashMap</code></a>.</li>
<li>
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentNavigableMap.html"><code>ConcurrentNavigableMap</code></a> is a subinterface of <code>ConcurrentMap</code> that supports approximate matches. The standard general-purpose implementation of <code>ConcurrentNavigableMap</code> is 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentSkipListMap.html"><code>ConcurrentSkipListMap</code></a>, which is a concurrent analog of 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html"><code>TreeMap</code></a>.</li>
</ul>
<p>All of these collections help avoid <a href="memconsist.html">Memory Consistency Errors</a> by defining a happens-before relationship between an operation that adds an object to the collection with subsequent operations that access or remove that object.</p>

        </div><div id="PageTitle"><h1>Atomic Variables</h1></div><div id="PageContent">

<p>The 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/package-summary.html"><code>java.util.concurrent.atomic</code></a> package defines classes that support atomic operations on single variables. All classes have <code>get</code> and <code>set</code> methods that work like reads and writes on <code>volatile</code> variables. That is, a <code>set</code> has a happens-before relationship with any subsequent <code>get</code> on the same variable. The atomic <code>compareAndSet</code> method also has these memory consistency features, as do the simple atomic arithmetic methods that apply to integer atomic variables.</p>
<p>To see how this package might be used, let&apos;s return to the 
<a class="SourceLink" target="_blank" href="examples/Counter.java" onclick="showCode(&apos;../../displayCode.html&apos;, &apos;examples/Counter.java&apos;); return false;"><code><code>Counter</code></code></a> class we originally used to demonstrate thread interference:</p>
<div class="codeblock"><pre>

class Counter {
    private int c = 0;

    public void increment() {
        c++;
    }

    public void decrement() {
        c--;
    }

    public int value() {
        return c;
    }

}
</pre></div>
<p>One way to make <code>Counter</code> safe from thread interference is to make its methods synchronized, as in 
<a class="SourceLink" target="_blank" href="examples/SynchronizedCounter.java" onclick="showCode(&apos;../../displayCode.html&apos;, &apos;examples/SynchronizedCounter.java&apos;); return false;"><code><code>SynchronizedCounter</code></code></a>:</p>
<div class="codeblock"><pre>

class SynchronizedCounter {
    private int c = 0;

    public synchronized void increment() {
        c++;
    }

    public synchronized void decrement() {
        c--;
    }

    public synchronized int value() {
        return c;
    }

}
</pre></div>
<p>For this simple class, synchronization is an acceptable solution. But for a more complicated class, we might want to avoid the liveness impact of unnecessary synchronization. Replacing the <code>int</code> field with an <code>AtomicInteger</code> allows us to prevent thread interference without resorting to synchronization, as in 
<a class="SourceLink" target="_blank" href="examples/AtomicCounter.java" onclick="showCode(&apos;../../displayCode.html&apos;, &apos;examples/AtomicCounter.java&apos;); return false;"><code><code>AtomicCounter</code></code></a>:</p>
<div class="codeblock"><pre>

import java.util.concurrent.atomic.AtomicInteger;

class AtomicCounter {
    private AtomicInteger c = new AtomicInteger(0);

    public void increment() {
        c.incrementAndGet();
    }

    public void decrement() {
        c.decrementAndGet();
    }

    public int value() {
        return c.get();
    }

}
</pre></div>

        </div><div id="PageTitle"><h1>Concurrent Random Numbers</h1></div><div id="PageContent">

<p>In JDK 7, 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html"><code>java.util.concurrent</code></a> includes a convenience class, 
<a class="APILink" target="_blank" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadLocalRandom.html"><code>ThreadLocalRandom</code></a>, for applications that expect to use random numbers from multiple threads or <code>ForkJoinTask</code>s.</p>
<p>For concurrent access, using <code>ThreadLocalRandom</code> instead of <code>Math.random()</code> results in less contention and, ultimately, better performance.</p>
<p>All you need to do is call <code>ThreadLocalRandom.current()</code>, then call one of its methods to retrieve a random number. Here is one example:</p>
<div class="codeblock"><pre>
int r = ThreadLocalRandom.current() .nextInt(4, 77);
</pre></div>

        </div><div id="PageTitle"><h1>For Further Reading</h1></div><div id="PageContent">

<ul>
<li><i>Concurrent Programming in Java: Design Principles and Pattern (2nd Edition)</i> by Doug Lea. A comprehensive work by a leading expert, who&apos;s also the architect of the Java platform&apos;s concurrency framework.</li>
<li><i>Java Concurrency in Practice</i> by Brian Goetz, Tim Peierls, Joshua Bloch, Joseph Bowbeer, David Holmes, and Doug Lea. A practical guide designed to be accessible to the novice.</li>
<li><i>Effective Java Programming Language Guide (2nd Edition)</i> by Joshua Bloch. Though this is a general programming guide, its chapter on threads contains essential &quot;best practices&quot; for concurrent programming.</li>
<li><i>Concurrency: State Models &amp; Java Programs (2nd Edition)</i>, by Jeff Magee and Jeff Kramer. An introduction to concurrent programming through a combination of modeling and practical examples.</li>
<li><i>
<a class="OutsideLink" target="_blank" href="http://sourceforge.net/projects/javaconcurrenta/">Java Concurrent Animated</a>:</i> Animations that show usage of concurrency features.</li>
</ul>

        </div><div id="PageTitle"><h1>Questions and Exercises: Concurrency</h1></div><div id="PageContent">

<h2>Questions</h2>
<ol>
<li>Can you pass a <code>Thread</code> object to <code>Executor.execute</code>? Would such an invocation make sense?</li>
</ol>
<h2>Exercises</h2>
<ol>
<li>Compile and run 
<a class="SourceLink" target="_blank" href="BadThreads.java" onclick="showCode(&apos;../../../displayCode.html&apos;, &apos;BadThreads.java&apos;); return false;"><code><code>BadThreads.java</code></code></a>:
<div class="codeblock"><pre>

public class BadThreads {

    static String message;

    private static class CorrectorThread
        extends Thread {

        public void run() {
            try {
                sleep(1000); 
            } catch (InterruptedException e) {}
            // Key statement 1:
            message = &quot;Mares do eat oats.&quot;; 
        }
    }

    public static void main(String args[])
        throws InterruptedException {

        (new CorrectorThread()).start();
        message = &quot;Mares do not eat oats.&quot;;
        Thread.sleep(2000);
        // Key statement 2:
        System.out.println(message);
    }
}
</pre></div>
<p>The application should print out &quot;Mares do eat oats.&quot; Is it guaranteed to always do this? If not, why not? Would it help to change the parameters of the two invocations of <code>Sleep</code>? How would you guarantee that all changes to <code>message</code> will be visible in the main thread?</p>
</li>
<li>Modify the producer-consumer example in <a href="../guardmeth.html">Guarded Blocks</a> to use a standard library class instead of the <code>Drop</code> class.</li>
</ol>
<p>
<a class="TutorialLink" target="_top" href="answers.html">Check your answers.</a></p>


        </div></div>
      </body>
      </html>